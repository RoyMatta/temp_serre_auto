#include <Adafruit_MCP23X17.h>  //SPI
#include <Adafruit_MAX31865.h>  //PT100 température
#include <Wire.h>
#include <SPI.h>

#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <Arduino.h>

#define PWM1 26
#define DIR1 25      

#define MOTEUR_ARRET 0
#define MOTEUR_MONTEE 1
#define MOTEUR_DESCENTE 2

// Pins SPI Communication
// #define MOSI_pin    23
// #define MISO_pin    19
// #define CLK_pin     18
// Pins CS températureAmplificateur de sonde de température PT100 MAX31865
// #define MODULE_TEMP_A_CS  2
// #define MODULE_TEMP_B_CS  15
// Variables température
// #define RREF      430.0 // The value of the reference resistor. Use 430.0 for PT100
// #define RNOMINAL  100.0 // The 'nominal' 0-degrees-C resistance of the sensor. Use 100.0 for PT100

// Capteurs de fin de cours
#define MOTEUR_A_FC_BAS         13 
#define MOTEUR_A_FC_HAUT        12
#define MOTEUR_B_FC_BAS         14
#define MOTEUR_B_FC_HAUT        27

// Adafruit_MAX31865 thermo1 = Adafruit_MAX31865(MODULE_TEMP_A_CS, MOSI_pin, MISO_pin, CLK_pin);
// Adafruit_MAX31865 thermo2 = Adafruit_MAX31865(MODULE_TEMP_B_CS, MOSI_pin, MISO_pin, CLK_pin);


//Définition de la structure du moteur
typedef struct T_Moteur {
  int pwm;    //pin responsable du pwm
  int dir;    //pin responsable de la direction du moteur
  int etat;    //valuer qui indique l'état du moteur
  unsigned long timestamp; //timestamp responsable de la durée de marche du moteur
  int capteur_FC_haut;  //capteur de fin de course haut
  int capteur_FC_bas;  //capteur de fin de course bas
//   int pin_LED_temoin;  //Led qui indique l'état du moteur s'il est en marche ou arret
} T_Moteur ;

T_Moteur lMoteurs[]= 
  {
     { PWM1, DIR1, MOTEUR_ARRET, 0, MOTEUR_A_FC_HAUT, MOTEUR_A_FC_BAS} //0, MOTEUR_A_FC_HAUT, MOTEUR_A_FC_BAS, LED_MARCHE_MOT_A}, //Moteur 1
    //  { PWM2, DIR2, MOTEUR_ARRET} //0, MOTEUR_B_FC_HAUT, MOTEUR_B_FC_BAS, LED_MARCHE_MOT_B} //Moteur 2
  };

// float readTemp(Adafruit_MAX31865& thermo1, Adafruit_MAX31865& thermo2);
void arretMoteur(int numero);
void monteeMoteur(int numero);
void descenteMoteur(int numero);
bool isMoteurActif(int numero);


bool to_stop = false;
/// @brief désactive un moteur si un critère d'arret est vérifié : timeout, rapport d'ouverture si mode auto activé, capteur FC
/// @param numero 
bool check_moteur(int numero) {   //TBD ajouter variation d'un timeout pour mode manu, ajouter argument timeout
  to_stop = false;
  if(lMoteurs[numero].etat == MOTEUR_MONTEE && !digitalRead(lMoteurs[numero].capteur_FC_haut)) { //TBD bool moteur FC capté
    Serial.println("Fin de course haut atteinte, arrêt du moteur");
    to_stop = true;
  } 
  if(lMoteurs[numero].etat == MOTEUR_DESCENTE && !digitalRead(lMoteurs[numero].capteur_FC_bas)) { //TBD bool moteur FC capté
    Serial.println("Fin de course bas atteinte, arrêt du moteur");
    to_stop = true;
  } 
  return to_stop;
}

void testFinDeCourse(int numero) {
    Serial.println("Test montée du moteur...");
    monteeMoteur(numero);
    while (!check_moteur(numero)) {
        Serial.print("FC haut: ");
        Serial.println(digitalRead(lMoteurs[numero].capteur_FC_haut));
        delay(100); // Small delay for readability
    }
    arretMoteur(numero);
    Serial.println("Fin de course haute atteinte, moteur arrêté.");

    delay(3000); // Pause before changing direction

    Serial.println("Test descente du moteur...");
    descenteMoteur(numero);
    while (!check_moteur(numero)) {
        Serial.print("FC bas: ");
        Serial.println(digitalRead(lMoteurs[numero].capteur_FC_bas));
        delay(100); // Small delay for readability
    }
    arretMoteur(numero);
    Serial.println("Fin de course basse atteinte, moteur arrêté.");
     delay(3000);
}


void setup(){
    Serial.begin(115200);
    delay(1000);
    Serial.println("Demarrage test moteur et température avec Fin de course");

    // Initialize SPI
    // thermo1.begin(MAX31865_3WIRE);
    // thermo2.begin(MAX31865_3WIRE);

    pinMode(lMoteurs[0].capteur_FC_haut, INPUT_PULLUP);
    pinMode(lMoteurs[0].capteur_FC_bas, INPUT_PULLUP);
    // pinMode(lMoteurs[1].capteur_FC_haut, INPUT_PULLUP);
    // pinMode(lMoteurs[1].capteur_FC_bas, INPUT_PULL
    
    pinMode(lMoteurs[0].pwm, OUTPUT);
    pinMode(lMoteurs[0].dir, OUTPUT);
    arretMoteur(0);
}

void loop(){
    // float temp = readTemp(thermo1, thermo2);
    // Serial.print("Température moyenne : ");
    // Serial.print(temp);
    // Serial.println(" °C");
    
    // if(temp < 25.0) {
    //     Serial.println("Température basse, descente du moteur");
    //     lMoteurs[0].etat = MOTEUR_DESCENTE; //reset l'état du moteur pour forcer la descente
        
    // } else if(temp > 27.0) {
    //     Serial.println("Température haute, montée du moteur");
    //     lMoteurs[0].etat = MOTEUR_MONTEE; //reset l'état du moteur pour forcer la montée 
        
    // } else {
    //     Serial.println("Température OK, arrêt du moteur");
    //     lMoteurs[0].etat = MOTEUR_ARRET; //reset l'état du moteur pour forcer l'arrêt
    // }
    
    // Serial.print("Capteur FC haut : " );
    // Serial.println(digitalRead(lMoteurs[0].capteur_FC_haut));
    // Serial.print("Capteur FC bas : ");
    // Serial.println(digitalRead(lMoteurs[0].capteur_FC_bas));
    testFinDeCourse(0);
    // if(lMoteurs[0].etat == MOTEUR_MONTEE && !check_moteur(0)) {
    //     monteeMoteur(0);
    // } else if(lMoteurs[0].etat == MOTEUR_DESCENTE && !check_moteur(0)) {
    //     descenteMoteur(0);
    // } else {
    //     arretMoteur(0);
    // }

}

// float readTemp(Adafruit_MAX31865& thermo1, Adafruit_MAX31865& thermo2) {
//     float temp1 = thermo1.temperature(RNOMINAL, RREF);
//     float temp2 = thermo2.temperature(RNOMINAL, RREF);
//     return (temp1 + temp2) / 2.0;
// }

/// @brief arrete le moteur grâce à son numéro (0 ou 1)
/// @param numero 
void arretMoteur(int numero) {
  if(lMoteurs[numero].etat == MOTEUR_ARRET) {
    return;
  }
  digitalWrite(lMoteurs[numero].dir, LOW);
  digitalWrite(lMoteurs[numero].pwm, LOW);
  lMoteurs[numero].etat = MOTEUR_ARRET;
}

void monteeMoteur(int numero) { //demarrage du moteur
  if(lMoteurs[numero].etat == MOTEUR_MONTEE) { //si déjà actif
    return;
  }
  digitalWrite(lMoteurs[numero].pwm, HIGH);
  digitalWrite(lMoteurs[numero].dir, LOW);    //TBD REMPLACER LOW par sens_montee et définir sens_montée
  lMoteurs[numero].etat = MOTEUR_MONTEE;
}

void descenteMoteur(int numero) { //demarrage du moteur
  if(lMoteurs[numero].etat == MOTEUR_DESCENTE) { //si déjà actif
    return;
  }
  digitalWrite(lMoteurs[numero].pwm, HIGH);
  digitalWrite(lMoteurs[numero].dir, HIGH);   //TBD
  lMoteurs[numero].etat = MOTEUR_DESCENTE;
}

bool isMoteurActif(int numero) {
  return !(lMoteurs[numero].etat == MOTEUR_ARRET);
}
